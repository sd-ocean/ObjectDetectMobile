package vn.edu.usth.objectdetectmobile;

import android.content.Context;

import androidx.annotation.NonNull;

import java.nio.FloatBuffer;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import ai.onnxruntime.OnnxTensor;
import ai.onnxruntime.OnnxValue;
import ai.onnxruntime.OrtEnvironment;
import ai.onnxruntime.OrtException;
import ai.onnxruntime.OrtSession;

/**
 * Lightweight wrapper around the Depth Anything ONNX model.
 * Creates a fresh ORT session for each inference so the detector can continue running even
 * if depth runs out of memory. This keeps the two pipelines decoupled.
 */
public class DepthEstimator implements AutoCloseable {
    private static final String MODEL_NAME = "depth_anything_v2_vits_fp16.onnx";

    public static class DepthMap {
        public final float[] depth;
        public final int width, height;
        public final float min, max;

        public DepthMap(float[] depth, int width, int height, float min, float max) {
            this.depth = depth;
            this.width = width;
            this.height = height;
            this.min = min;
            this.max = max;
        }
    }

    private static final float NEAR_CM = 30f;  // tweak to calibrate near distance
    private static final float FAR_CM = 500f;  // tweak to calibrate far distance

    private final OrtEnvironment env;
    private final OrtSession.SessionOptions sessionOptions;
    private final String modelPath;

    private final int inputSize = 518;
    private final int multiple = 14;
    private final float[] mean = {0.485f, 0.456f, 0.406f};
    private final float[] std = {0.229f, 0.224f, 0.225f};

    public DepthEstimator(@NonNull Context ctx) throws OrtException {
        env = OrtEnvironment.getEnvironment();
        modelPath = ObjectDetector.Util.cacheAsset(ctx, MODEL_NAME);
        sessionOptions = new OrtSession.SessionOptions();
    }

    public List<ObjectDetector.Detection> attachDepth(List<ObjectDetector.Detection> dets,
                                                      DepthMap depthMap) {
        if (dets == null || depthMap == null) return dets;
        List<ObjectDetector.Detection> enriched = new ArrayList<>(dets.size());
        for (ObjectDetector.Detection d : dets) {
            enriched.add(d.withDepth(averageDepth(depthMap, d)));
        }
        return enriched;
    }

    public DepthMap estimate(int[] argb, int srcW, int srcH) throws OrtException {
        Prep prep = preprocess(argb, srcW, srcH);
        long[] shape = new long[]{1, 3, prep.h, prep.w};
        OnnxTensor input = OnnxTensor.createTensor(env, FloatBuffer.wrap(prep.chw), shape);

        float[] rawDepth;
        int rawH, rawW;
        try (OrtSession session = env.createSession(modelPath, sessionOptions);
             OnnxTensor tensor = input) {
            String inputName = session.getInputInfo().keySet().iterator().next();
            try (OrtSession.Result out = session.run(Collections.singletonMap(inputName, tensor))) {
                OnnxValue ov = out.get(0);
                OnnxTensor depthTensor = (OnnxTensor) ov;
                long[] outShape = depthTensor.getInfo().getShape(); // expect [1,H,W]
                rawH = (int) outShape[1];
                rawW = (int) outShape[2];
                FloatBuffer buf = depthTensor.getFloatBuffer();
                rawDepth = new float[buf.remaining()];
                buf.get(rawDepth);
            }
        }

        float[] depthFull = resizeBilinear(rawDepth, rawW, rawH, srcW, srcH);
        float min = Float.MAX_VALUE, max = -Float.MAX_VALUE;
        for (float v : depthFull) {
            if (v < min) min = v;
            if (v > max) max = v;
        }
        return new DepthMap(depthFull, srcW, srcH, min, max);
    }

    private static float averageDepth(DepthMap map, ObjectDetector.Detection d) {
        if (map.width == 0 || map.height == 0) return Float.NaN;
        int x1 = clamp((int)Math.floor(d.x1), 0, map.width-1);
        int y1 = clamp((int)Math.floor(d.y1), 0, map.height-1);
        int x2 = clamp((int)Math.ceil(d.x2), 0, map.width-1);
        int y2 = clamp((int)Math.ceil(d.y2), 0, map.height-1);
        int spanX = Math.max(1, x2 - x1);
        int spanY = Math.max(1, y2 - y1);
        int stepX = Math.max(1, spanX / 12);
        int stepY = Math.max(1, spanY / 12);
        float sum = 0f; int count = 0;
        for (int y=y1; y<=y2; y+=stepY) {
            int base = y * map.width;
            for (int x=x1; x<=x2; x+=stepX) {
                sum += map.depth[base + x];
                count++;
            }
        }
        if (count == 0) return Float.NaN;
        float raw = sum / count;
        float norm = normalize(raw, map.min, map.max);
        return toCentimeters(norm);
    }

    private static float normalize(float v, float min, float max) {
        float range = max - min;
        if (range < 1e-6f) return 0f;
        float n = (v - min) / range;
        return Math.max(0f, Math.min(1f, n));
    }

    private static float toCentimeters(float normalized) {
        if (Float.isNaN(normalized)) return Float.NaN;
        return NEAR_CM + normalized * (FAR_CM - NEAR_CM);
    }

    private static class Prep {
        final float[] chw;
        final int w,h;
        Prep(float[] chw, int w, int h) {
            this.chw = chw; this.w = w; this.h = h;
        }
    }

    private Prep preprocess(int[] argb, int srcW, int srcH) {
        float scale = Math.max(inputSize/(float)srcW, inputSize/(float)srcH);
        int resizedW = roundToMultiple(Math.round(srcW*scale), multiple);
        int resizedH = roundToMultiple(Math.round(srcH*scale), multiple);
        int[] resized = resizeNearest(argb, srcW, srcH, resizedW, resizedH);
        int size = resizedW*resizedH;
        float[] chw = new float[3*size];
        int rIdx=0,gIdx=size,bIdx=2*size;
        for (int i=0;i<size;i++){
            int p = resized[i];
            float r = ((p>>16)&0xFF)/255f;
            float g = ((p>>8)&0xFF)/255f;
            float b = (p&0xFF)/255f;
            chw[rIdx++] = (r - mean[0]) / std[0];
            chw[gIdx++] = (g - mean[1]) / std[1];
            chw[bIdx++] = (b - mean[2]) / std[2];
        }
        return new Prep(chw, resizedW, resizedH);
    }

    private static int[] resizeNearest(int[] src, int srcW, int srcH, int dstW, int dstH) {
        int[] dst = new int[dstW*dstH];
        float sx = dstW / (float)srcW;
        float sy = dstH / (float)srcH;
        for (int y=0;y<dstH;y++){
            int py = Math.min((int)(y / sy), srcH-1);
            for (int x=0;x<dstW;x++){
                int px = Math.min((int)(x / sx), srcW-1);
                dst[y*dstW + x] = src[py*srcW + px];
            }
        }
        return dst;
    }

    private static float[] resizeBilinear(float[] src, int srcW, int srcH, int dstW, int dstH) {
        if (srcW==dstW && srcH==dstH) return src.clone();
        float[] dst = new float[dstW*dstH];
        float xRatio = dstW>1 ? (srcW-1f)/(dstW-1f):0f;
        float yRatio = dstH>1 ? (srcH-1f)/(dstH-1f):0f;
        for (int y=0;y<dstH;y++){
            float sy = y * yRatio;
            int y0 = (int)Math.floor(sy);
            int y1 = Math.min(y0+1, srcH-1);
            float ly = sy - y0;
            for (int x=0;x<dstW;x++){
                float sx = x * xRatio;
                int x0 = (int)Math.floor(sx);
                int x1 = Math.min(x0+1, srcW-1);
                float lx = sx - x0;
                float top = lerp(src[y0*srcW + x0], src[y0*srcW + x1], lx);
                float bottom = lerp(src[y1*srcW + x0], src[y1*srcW + x1], lx);
                dst[y*dstW + x] = lerp(top, bottom, ly);
            }
        }
        return dst;
    }

    private static float lerp(float a,float b,float t){ return a + (b-a)*t; }
    private static int clamp(int v,int lo,int hi){ return v<lo?lo:(Math.min(v, hi)); }
    private static int roundToMultiple(int value,int multiple){
        if (multiple<=1) return value;
        int q = Math.round(value/(float)multiple);
        return Math.max(multiple, q*multiple);
    }

    @Override
    public void close() throws Exception {
        sessionOptions.close();
        env.close();
    }
}
